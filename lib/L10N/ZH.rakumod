# This file contains the ……… Slang of the Raku Programming Language

#- start of generated part of localization ------------------------------------
#- Generated on 2025-09-21T12:41:56+08:00 by update-localization.raku
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

role L10N::ZH {
    use experimental :rakuast;
    token block-default { 其他情况}
    token block-else { 否则}
    token block-elsif { 否则如果}
    token block-for { 对每个}
    token block-given { 针对}
    token block-if { 如果}
    token block-loop { 无条件循环}
    token block-orwith { 或用}
    token block-repeat { 重复执行}
    token block-unless { 如果不}
    token block-until { 直到}
    token block-when { 若是}
    token block-whenever { 每当}
    token block-while { 有条件循环}
    token block-with { 若定义且真}
    token block-without { 若未定义或假}
    token constraint-where { where}
    token enum-BigEndian { BigEndian}
    token enum-Broken { 失约}
    token enum-False { 假}
    token enum-FileChanged { FileChanged}
    token enum-FileRenamed { FileRenamed}
    token enum-Kept { 履约}
    token enum-Less { 少}
    token enum-LittleEndian { LittleEndian}
    token enum-More { 多}
    token enum-NativeEndian { NativeEndian}
    token enum-Planned { 准备中}
    token enum-Same { 相等}
    token enum-SeekFromBeginning { SeekFromBeginning}
    token enum-SeekFromCurrent { SeekFromCurrent}
    token enum-SeekFromEnd { SeekFromEnd}
    token enum-True { 真}
    token infix-pcontp { "(cont)"}
    token infix-pelemp { "(elem)"}
    token infix-cff { "^ff"}
    token infix-cffc { "^ff^"}
    token infix-cfff { "^fff"}
    token infix-cfffc { "^fff^"}
    token infix-after { 之后}
    token infix-and { 和}
    token infix-andthen { 然后}
    token infix-before { 之前}
    token infix-but { 但}
    token infix-cmp { cmp}
    token infix-coll { coll}
    token infix-div { div}
    token infix-does { 能够}
    token infix-eq { eq}
    token infix-ff { ff}
    token infix-ffc { "ff^"}
    token infix-fff { fff}
    token infix-fffc { "fff^"}
    token infix-gcd { gcd}
    token infix-ge { ge}
    token infix-gt { gt}
    token infix-lcm { lcm}
    token infix-le { le}
    token infix-leg { leg}
    token infix-lt { lt}
    token infix-max { max}
    token infix-min { min}
    token infix-minmax { minmax}
    token infix-mod { mod}
    token infix-ne { ne}
    token infix-notandthen { notandthen}
    token infix-o { o}
    token infix-or { 或}
    token infix-orelse { 不然的话}
    token infix-unicmp { unicmp}
    token infix-x { x}
    token infix-X { X}
    token infix-xx { xx}
    token infix-Z { Z}
    token meta-R { R}
    token meta-X { X}
    token meta-Z { Z}
    token modifier-for { 对每个}
    token modifier-given { 针对}
    token modifier-if { 如果}
    token modifier-unless { 如果不}
    token modifier-until { 直到}
    token modifier-when { 若是}
    token modifier-while { 有条件循环}
    token modifier-with { 若后者定义且真}
    token modifier-without { 若后者未定义或假}
    token multi-multi { 多个}
    token multi-only { 只用此}
    token multi-proto { 分派原型}
    token package-class { 类}
    token package-grammar { 语法}
    token package-module { 模块}
    token package-package { 包}
    token package-role { 能力}
    token phaser-BEGIN { 编译时}
    token phaser-CATCH { 捕获错误}
    token phaser-CHECK { 编译完成时}
    token phaser-CLOSE { 供应结束时}
    token phaser-CONTROL { 控制流异常时}
    token phaser-DOC { 文档}
    token phaser-END { 程序结束时}
    token phaser-ENTER { 每次进入块时}
    token phaser-FIRST { 循环开始前}
    token phaser-INIT { 程序运行前}
    token phaser-KEEP { 每次块功成身退时}
    token phaser-LAST { 循环或供应结束后}
    token phaser-LEAVE { 每次退出块时}
    token phaser-NEXT { 循环下一轮前}
    token phaser-POST { 块后置条件}
    token phaser-PRE { 块前置条件}
    token phaser-QUIT { 供应提前终止}
    token phaser-UNDO { 每次块功败而归时}
    token prefix-not { not}
    token prefix-so { so}
    token quote-lang-m { m}
    token quote-lang-ms { ms}
    token quote-lang-q { q}
    token quote-lang-Q { Q}
    token quote-lang-qq { qq}
    token quote-lang-rx { rx}
    token quote-lang-s { s}
    token quote-lang-S { S}
    token quote-lang-ss { ss}
    token quote-lang-Ss { Ss}
    token routine-method { 方法}
    token routine-regex { 正则}
    token routine-rule { 规则}
    token routine-sub { 过程}
    token routine-submethod { 非继承方法}
    token routine-token { 符号}
    token scope-anon { 匿名}
    token scope-augment { 增补}
    token scope-constant { 常量}
    token scope-has { 属性}
    token scope-HAS { 属性自定义}
    token scope-my { 局部}
    token scope-our { 公开}
    token scope-state { 持续量}
    token scope-unit { 单元}
    token stmt-prefix-also { also}
    token stmt-prefix-do { do}
    token stmt-prefix-eager { eager}
    token stmt-prefix-gather { 收集}
    token stmt-prefix-hyper { hyper}
    token stmt-prefix-lazy { lazy}
    token stmt-prefix-quietly { quietly}
    token stmt-prefix-race { race}
    token stmt-prefix-react { react}
    token stmt-prefix-sink { sink}
    token stmt-prefix-start { start}
    token stmt-prefix-supply { supply}
    token stmt-prefix-try { 试试}
    token term-nano { nano}
    token term-now { now}
    token term-pi { pi}
    token term-rand { rand}
    token term-self { 本对象}
    token term-tau { tau}
    token term-time { time}
    token traitmod-does { 能够}
    token traitmod-handles { 委托责任给}
    token traitmod-hides { 偷摸着继承}
    token traitmod-is { is}
    token traitmod-of { of}
    token traitmod-returns { 返回类型}
    token traitmod-trusts { trusts}
    token typer-enum { 选项集}
    token typer-subset { 子集}
    token use-import { 导入}
    token use-need { 依赖于}
    token use-no { 不使用}
    token use-require { 动态使用}
    token use-use { 使用}
    method core2ast {
        my constant %mapping = "所有", "all", "任一", "any", "等待", "await", "造物", "bless", "是否定义", "defined", "听诊", "diag", "崩溃", "die", "收工", "done", "失败", "fail", "fail", "fail", "终止循环", "last", "下一轮循环", "next", "没有一个", "none", "注意", "note", "恰好一个", "one", "打印", "print", "print", "print", "格式化打印", "printf", "printf", "printf", "继续", "proceed", "proceed", "proceed", "提示输入", "prompt", "prompt", "prompt", "输出", "put", "put", "put", "重新此轮循环", "redo", "返回", "return", "执行", "run", "述", "say", "完成", "succeed", "succeed", "succeed", "收集值", "take", "警告", "warn";
        my $ast := self.ast;
        my $name := $ast ?? $ast.simple-identifier !! self.Str;
        if %mapping{$name} -> $original {
            RakuAST::Name.from-identifier($original)
        }
        else {
            $ast // RakuAST::Name.from-identifier($name)
        }
    }
    method trait-is2ast {
        my constant %mapping = "默认情况", "default", "弃用", "DEPRECATED", "裸名导出", "export", "可写", "rw", "rw", "rw";
        my $ast := self.ast;
        my $name := $ast ?? $ast.simple-identifier !! self.Str;
        if %mapping{$name} -> $original {
            RakuAST::Name.from-identifier($original)
        }
        else {
            $ast // RakuAST::Name.from-identifier($name)
        }
    }
    method adverb-pc2str (str $key) {
        my constant %mapping = "删除", "delete", "是否存在", "exists";
        %mapping{$key} // $key
    }
    method adverb-q2str (str $key) {
        $key
    }
    method adverb-rx2str (str $key) {
        $key
    }
    method named2str (str $key) {
        $key
    }
    method pragma2str (str $key) {
        $key
    }
    method system2str (str $key) {
        my constant %mapping = "构造对象", "BUILD", "BUILD", "BUILD", "程序入口", "MAIN", "MAIN", "MAIN", "调整对象", "TWEAK", "TWEAK", "TWEAK";
        %mapping{$key} // $key
    }
}

# The EXPORT sub that actually does the slanging
my sub EXPORT($dontslang?) {
    unless $dontslang {
        my $LANG := $*LANG;
        $LANG.define_slang('MAIN',
          $LANG.slang_grammar('MAIN').^mixin(L10N::ZH)
        );
    }

    BEGIN Map.new
}

#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of localization --------------------------------------

# vim: expandtab shiftwidth=4
